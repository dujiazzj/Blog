---
layout: post
title: Effective Objective-c 2.0(1)
category: 代码优雅之道
---

#Effective Objective-c 2.0 (编写高质量ios和os x的52个有效方法) 有感

已经忘记在哪里看到过这么一句话“永远不用吝啬买书的钱”。这也是我在看了这本书之后的第一个感谢，收获真的太多了。虽然在我写这篇观后感的时候我才看了三分之一。一味的coding，一味的接项目，一味的实践效率真不是很高，总会觉得遇到了瓶颈，感觉自己很久没有显著提高的朋友们，其实上帝在给我们发消息呢。send_Msg(@"你该看书了！！！")。

在看这本书之前，我会觉得OC其实也就那样，没什么难点嘛。其实想想自己真的很幼稚，自己接触的都只是最表面的东西，真是只要是个人都能看懂的东西。而我却自以为是的认为自己已经精通了。好了，不多说了，我们就来看看我的这些笔记吧。我相信对大部分人来说还是很受用的。

##第一条，了解Objective-c语言的起源

- OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型，收到一条消息之后究竟应执行何种代码，由运行期环境而非编译器来决定。
- 对象所占的内存总是分配在堆中的，绝不会分配在栈上，不能在栈上分配Objective-C对象。
```
NSString *someString = @"The string";
NSString *anotherString = someString;
```
在堆中分配了一块内存存放@"The string"。在栈上有两个内存分别存放指针someString、anotherString，这两个指针中的内容就是堆上的@"The string"内存地址。

- 与创建结构体相比，创建对象还需要额外的开销，例如分配及释放堆内存等。如果只需要保存int、float、double、char等"非对象类型"。那么通常使用CGRect这种结构体就够了。
##第二条，在类的头文件中尽量少引入其他头文件

- 可以用“@class”(向前引用)只有在必须引入其他头文件的时候才可以引入，多余的引入其他头文件会大大地增加编译时间。
- 遇到协议之类的，必须引入其他头文件的情况时，可以把协议放在一个单独的文件中，但是对于委托协议就没有办法啦。

##第三条，多用字面量语法，少用与之等价的方法（语法糖）

- 字面量
```
NSNumber *intNumber = @1;
NSNumber *float = @2.5f;
NSNumber *double = @3.14159;
NSNumber *bool = @YES;
NSNumber *char = @'a';
```
- 字面量数组
```
NSArray = @[@"1",@"2"]; //在这里数组中的内容不能为空
```
当字面量数组或者字典中有nil时，程序会抛出异常，这有助于作者更快的发现错误，这是正常语法所不能做到的。

- 字面量语法都是不可变的，例如不可变的数组和字典，以下code可以使字面量可变
```
NSMutableArray * mutable = [@[@1,@2,@3,@4,@5]mutableCopy];
```

##第4条，多用类型常量，少用#define预处理指令

- 宏定义将会替换所有符合的字符串，且没有携带类型信息，即使有人重新定义了常量值，编译器也不会产生警告信息


```
#define ANIMATION_DUATION    0.3

#***.m
static const NSTimeInterval kAnimationDuration = 0.3 //若局限于实现文件则前面加k，若是全局的这前面加类型前缀，这是命名规范，切记啊
```

```
#***.h
extern NSString *const EOCStringConstant;
#***.m
NSString *const EOCStringConstant = @"Value";
```

如果试图写该const修饰的变量，编译器会报错，二static修饰符则意味着该变量仅在定义此变量的编译单元可见（实现文件）

- 在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中。需要用类名做前缀。

##第5条，用枚举表示状态、选项、状态码

- 指定枚举的底层数据所用类型：

```
enum EOCConnectionState : NSInteger {/*....*/}
```

- 也可以手动指定某个枚举值的值
- Foundation框架定义了一些辅助宏，用这些宏来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型，这些宏具备向后兼容能力，如果目标平台的编译器支持新标准时，那就使用新式语法。
- 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。
- 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。
- 在处理枚举来信的switch语句中不要实现default分支。这样的话，加入新枚举之后编译器就会提示开发者：switch并未处理所有的枚举。

##第6条，理解属性这一概念

- 尽量不要直接访问实例变量，而应该通过存取的方法来做。
-@dynamic,编译器不会为属性创建存取方法，也不要为其创建存取方法。在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信方法可以在运行期找到。例如CoreData中的NSManagedObject的子类。
- 属性特质：

    - 原子性：

        - atomicity，编译器所合成的方法会通过锁定机制确保其原子性
        - nonatomic，不使用原子锁。

    - 读/写权限

        - readwrite:可读可写，默认的。
        - readonly:只是可读的，仅有get方法，没有set方法。

    - 内存管理语义
        - assign：只会执行针对“纯量类型”的简单赋值操作
        - strong：“拥有关系”，为这种属性设置新值时，先保留新值，再释放旧值，再将新值设置上去。
        - weak：“非拥有关系”，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，所指的对象遭到摧毁时，属性值也会清空。
        - unsafe_unretained：适用于对象类型的assign，也是“非拥有关系”，和weak不同的是，当所指的对象被销毁时，也不会自动清空，所以是不安全的。
        - copy，与strong类似，不过不保留新值，而是拷贝一份。在可变的属性中都应该拷贝一份。

    - 方法名
        - getter = &lt;name>，指定获取方法的名称。
        - setter = &lt;name>，指定设置方法的名称。
        - 若自定义的方法就应该具备相关属性所具备的特质。比如‘copy’，在设置方法中就应该拷贝相关对象。

##第七条，在对象内部经理直接访问实例变量

- 在写入实例变量时，通过其设置方法，而在获取实例变量时，则直接访问，可以提高读取操作速度，又可以控制属性变量的写入。
- 在初始化方法及dealloc中应该直接访问实例变量，因为子类有可能覆写设置方法。
- ‘惰性初始化’，在这种情况下，必须通过获取方法才可以访问属性。

##第八条，理解“对象等同性”这一概念

- NSObject协议中有两个判断等同性的关键方法：

```
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
```

######NSObject默认实现是当且仅当指针值完全相同时，两个对象才想等。所有我们可以在自定义类中取重载这两个方法，不过重载要注意：如果`isEqual:`方法判定两个对象想等，那么其hash方法也必须返回相同的值，但是hash返回值相同，`isEqual:`判定未必想等。
- 若`-(NSUinteger)hash`返回一个固定之会影响性能。假如collection是用Set实现的，set可能会根据哈希码把对象分装到不同的数组中，在向set添加新对象时要根据哈希码找到与之相关的那个数组，并依次检索各个元素。
- 不要盲目地逐个检测每条属性，二十应该依照具体需求来制定检测方案。
- 编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法。

##第九条，以类族模式隐藏实现细节

- `类族`是一种设计模式，可以隐藏”抽象基类”的实现细节，比如UIKit框架中的UIButton：

```
+ (UIButton*)buttonWithType:(UIButtonType)type;
```

返回的对象取决于`type`,好像就是工厂模式。

- 编写类族的时候要注意，
    - 子类应该继承自类族中的抽象基类
    - 子类应该定义自己的数据存储方式
    - 子类应当覆写超类文档中指明需要覆盖的方法
 
##第十条，在既有类中使用关联对象存放自定义数据

- 通过关联对象存放自定义数据，可以让你不必取基础一个父类，在子类中添加相应熟悉。
- 往一个类中添加关联数据,需要先导入`objc/runtime.h`

```
    objc_setAssociatedObject(<#id object#>, <#const void *key#>, <#id value#>, <#objc_AssociationPolicy policy#>)
```

- 获取一个类中的关联数据

```
    objc_getAssociatedObject(<#id object#>, <#const void *key#>)
```

- 事例代码：

```
static void *key = @"AlertViewNewKey";
```

```
    UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@"标题"
                                                                              message:@"内容"
                                                                               delegate:self
                                                                 cancelButtonTitle:@"cancel"
                                                                 otherButtonTitles:@"other", nil];
    
    void (^block)(NSInteger) = ^(NSInteger buttonIndex){
        if (buttonIndex == 0)
        {
            NSLog(@"do cancel");
        }
        else
        {
            NSLog(@"do Other");
        }
    };
    objc_setAssociatedObject(alertView,
                             key,
                             block,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [alertView show];
```

```
#pragma mark - UIAlertView Delegate
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    void(^block)(NSInteger) = objc_getAssociatedObject(alertView,key);
    block(buttonIndex);
}
```

- 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的”拥有关系”和“非拥有关系“
