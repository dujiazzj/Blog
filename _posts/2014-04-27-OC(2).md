---
layout: post
title: Effective Objective-c 2.0(2)
category: 代码优雅之道
---

##第11条，理解objc_msgSend 的作用
    
    这一条是关于消息的传递机制，OC是C的超集，C语言使用“静态绑定”，在编译期就能决定运行期所应调用的函数。在编译器编译代码的时候就会生成相应函数的指令，函数地址是硬编码在指令之中的。OC是动态绑定，在运行期决定调用的方法。这也就是面对对象语言中的多态。

OC中的方法转为底层C语言的实现:
```
id returnValue = [someObject messaeName:parameter];
```
就会转化为
```
id returnValue = objc_msgSend(someObject,@select(messageName:),parameter)
```

`objc_msgSend`会通过在接收者类中搜寻其“方法列表”，若没有对应的选择子则沿着此类的继承体系继续搜寻，若是最后还是没有就会执行“消息转发”(message forwarding)。找到正确的方法之后就会马上跳转过去，之所以会跳转过去是因为OC中的对象的每个方法都可以视为简单的C函数，原型如下：

```
<return_type> Class_selector(id self, SEL _cmd, ...)
```
每个类中都有一张表格，其中的指针都会指向这种函数，而选择子的名称则是查表时所用的键。

OC使用“尾调用优化”(又称尾调用消除)来优化是跳转方法实现的更简单些。所谓的“尾调用优化”就是某函数的最后一项操作是调用另外一个函数，编译器就会生成跳转至另一函数所需的指令码，替换当前的栈桢，而不会向调用堆栈推入新的“栈桢”

如此复杂的步奏是不是会影响函数调用的效率呢？所幸objc_msgSend会将匹配结果缓存在“快速映射表”里面，每个类都有这样一个缓存，这样以后执行起来就会很快。

以上只是部分消息的调用过程，其他“边界清空”则需要OC运行环境中的另一些函数来调用：

- objc_msgSend_stret,发送的消息要返回结构体。
- objc_msgSend_fpret,发送的消息返回的是浮点数。
- objc_msgSendSuper,给超类发送消息

##第12条，理解消息转发机制
因为OC的消息运行期决定，所有有了消息转发机制，对应消息最后没有相应接收者的情况。
消息转发分为两大阶段：

- 第一阶段先征询接收者，所属的类，看其是否能动态添加方法，叫做“动态方法解析”。
- 第二阶段征询接受者是否有其他对象能处理这条消息，若有，则运行期系统会把消息转给那个对象，若没有则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接收者最后一次机会

对象在收到无法解读的消息之后，会调用相应的以下方法

```
+ (BOOL)resolveInstanceMethod:(SEL)selector;//调用实例方法
+ (BOOL)resolveClassMethod:(SEL)selector;//调用类方法
```

以下是用“resolveInstancemethod:”来实现 @dynamic属性

```
id autoDictionaryGetter(id self, SEL _cmd);
void autoDictionarySetter(id self, SEL _cmd, id value);

+ (BOOL)resolveInstanceMethod:(SEL)selector
{
    NSString *selectorString = NSStringFromSelector(selector);
    if(/* selector is from a @dynamic property */)
    {
        if([selectorString hasPrefix:@"set"])
        {
            class_addMethod(self,
                            selector,
                            (IMP)autoDictionarySetter,
                            "v@:@");
        }else
        {
            class_addMethod(self,
                            selector,
                            (IMP)autoDictionaryGetter,
                            "@@:");
        }
        return YES;
    }
    return [super resolveInstanceMethod:selector];
}
```

交给备援接收者处理无法处理的消息。接收者通过方法`- (id)forwardingTargetForSelector:(SEL)selector;`返回备援接收者

完整的消息转发

- 创建NSInvocation对象，把尚未处理的那条消息有关的全部细节都封装其中，包括选择子，目标，参数。在触发NSInvocation对象时，消息派发系统将亲自出马，把消息指派给目标对象。
此步骤调用下列方法来转发消息：`- (void)forwardInvocation:(NSInvocation*)invocation;`。这个方案的关键地方在于创建NSInvocation对象。若最后此选择子还是没有被处理，则该方法会调用`doesNotRecognizeSelector`以抛出异常。

消息转发机制，实现@@dynamic属性实例

```
#import <Foundation/Foundation.h>

@interface EOCAutoDictionary : NSObject
@property (nonatomic,strong)NSString* string;
@property (nonatomic,strong)NSNumber* number;
@property (nonatomic,strong)NSDate* date;
@property (nonatomic,strong)id opaqueObject;
@end
```

```
#import "EOCAutoDictionary.h"
#import <objc/runtime.h>

@interface EOCAutoDictionary()

@property (nonatomic,strong)NSMutableDictionary* backingStore;

@end

void autoDictionarySetter(id self,SEL _cmd,id value)
{
    EOCAutoDictionary* typedSelf = (EOCAutoDictionary*)self;
    NSMutableDictionary* backingstore = typedSelf.backingStore;
    NSMutableString* key = [NSStringFromSelector(_cmd) mutableCopy];
    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];
    [key deleteCharactersInRange:NSMakeRange(0, 3)];
    NSString* lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];
    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];
    if (value)
    {
        [backingstore setObject:value forKey:key];
    }
    else
    {
        [backingstore removeObjectForKey:key];
    }
}

id autoDictionaryGetter(id self, SEL _cmd)
{
    //Get the backing store from the object
    EOCAutoDictionary* typedSelf = (EOCAutoDictionary*)self;
    NSMutableDictionary* backingStore = typedSelf.backingStore;
    NSString* key = NSStringFromSelector(_cmd);
    return [backingStore objectForKey:key];
}

@implementation EOCAutoDictionary
@dynamic string,number,date,opaqueObject;

- (id)init
{
    if ((self = [super init]))
    {
        _backingStore = [NSMutableDictionary new];
    }
    return self;
}

+ (BOOL)resolveInstanceMethod:(SEL)sel
{
    NSString* selectorString = NSStringFromSelector(sel);
    if ([selectorString hasPrefix:@"set"])
    {
        class_addMethod(self, sel, (IMP)autoDictionarySetter, "v@:@");
    }
    else{
        class_addMethod(self, sel, (IMP)autoDictionaryGetter, "@@:");
    }
    return YES;
}
```

##第13条，用“方法调配技术”调试“黑盒方法”

一直不知道，OC可以不继承，不用源码，就可以更改一个已知类中的某个方法实现。
比如NSString 可以响应lowercaseString 和 uppercaseString等选择子。那类中会有一个选择子名称和实现映射的表。lowercaseString对应IMP1，uppercaseString对应IMP2。在这里我们可以调换这两个方法的实现，使lowercaseString 对应IMP2，uppercaseString对应IMP1.

```
//演示如何交换两个方法的实现
Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
    
    Method swapMethod = class_getInstanceMethod([NSString class], @selector(uppercaseString));
    
    method_exchangeImplementations(originalMethod, swapMethod);
```

```
//以下是替换NSString中的lowercaseString方法之后
#import <Foundation/Foundation.h>

@interface NSString (EOCAddition)
- (NSString*)eoc_lowcaseString;
@end
```

```
#import "NSString+EOCAddition.h"
#import <objc/runtime.h>
@implementation NSString (EOCAddition)
- (NSString*)eoc_lowcaseString
{
    Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
    
    Method swapMethod = class_getInstanceMethod([NSString class], @selector(eoc_lowcaseString));
    
    method_exchangeImplementations(originalMethod, swapMethod);
    
    NSString* lowercase = [self eoc_lowcaseString];
    NSLog(@"%@------>%@",self,lowercase);
    return lowercase;
}
@end
```

```
NSString* string = @"FanXiaoJun is a DaBian";
NSString* lowerString = [string lowercaseString];
NSLog(@"string%@ -------> %@",string,lowerString);

输出：2014-04-23 21:11:47.700 Demo[28564:303] stringFanXiaoJun is a DaBian -------> fanxiaojun is a dabian

```

但是这个方法只应该出现在调试的时候，而不应该被滥用，不然很难调试。

##第14条，理解“类对象”的用意

每个对象结构体的首个成员是Class类的变量，该变量定义了对象所属的类，通常称为“isa”指针。比如id类型定义为：

```
typedef struct objc_object{
    Class isa;
} *id;
```

Class对象也定义在运行期程序库的头文件中：

```
typedef struct objc_class *Class{
    Class isa;
    Class super_class;                            //定义超类（元类）
    const char *name;                             //定义类名
    long version;                                 //
    long info;
    long instance_size;
    struct objc_ivar_list *ivars;
    struct objc_method_list **methodLists;
    struct objc_cache *cache;
    struct objc_protocol_list *protocols;
}
```
假设有个名为SomeClass的子类从NSObject中继承来，则继承体系如下所示

```
                        ---------------             ------------------
                       |NSObject class | ---isa--> |NSObject metaclass|
                        ---------------             ------------------
                                ^                            ^
                                |super_class                 |super_class
                                |                            |
------------------       ------------------        ---------------------
SomeClass instance|-isa->|SomeClass class |---isa->|SomeClass metaclass|
------------------       ------------------        ---------------------
```