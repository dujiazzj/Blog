<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" />
    <!--[if lte IE 9]><meta http-equiv="refresh" content="0;url=/ie.html"><![endif]-->

    <title>OC优雅之道</title>
    <meta name="description" content="">

    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
  </head>
  <body>
    <aside id="sidebar">
      <nav id="tags">
        <a href="/index.html" id="avatar"></a>

        <ul id="tags__ul">
          <li id="js-label1" class="tags__li tags-btn active">All Posts</li>
          <li id="js-label2" class="tags__li tags-btn">
            代码优雅之道</li>
          <li id="js-label3" class="tags__li tags-btn">
            技术感想分享</li>
          <li id="js-label4" class="tags__li tags-btn">
            人生杂谈</li>
          <li id="js-label5" class="tags__li tags-btn">
            项目之路</li>
          <li id="js-label6" class="tags__li tags-btn">
            预留字段</li>
        </ul>

        <div id="tags__bottom">
          <a href="mailto:zzj19910517@gmail.com" id="icon-email" class="tags-btn fontello"></a>
          <a href="/rss.xml" id="icon-feed" class="tags-btn fontello"></a>
        </div>
      </nav> <!-- end #tags -->

      <div id="posts-list">
        <form action="" id="search-form">
          <a href="/index.html" id="mobile-avatar"></a>
          <!-- NOTE: input field is disabled by default -->
          <input id="search-input" type="text" placeholder="Search..." disabled >
        </form>

        <nav id="pl__container">
        
          <a class="代码优雅之道 pl__all" href="/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88-hello.html"><span class="pl__circle"></span><span class="pl__title">OC优雅之道</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="项目之路 pl__all" href="/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%B7%AF/2014/04/07/TeamTalk.html"><span class="pl__circle"></span><span class="pl__title">TeamTalk</span><span class="pl__date">Apr 2014</span></a>
        
          <a class="代码优雅之道 pl__all" href="/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/OC%281%29.html"><span class="pl__circle"></span><span class="pl__title">OC优雅之道</span><span class="pl__date">Apr 2014</span></a>
        
        </nav>
      </div> <!-- end #posts-list -->
    </aside> <!-- end #sidebar -->

    <div id="post">
      <div id="pjax">
        <article id="post__content">
  <h1 id="post__title" data-identifier="20140407">OC优雅之道</h1>
  <h1 id="effective_objectivec_20_iosos_x52_">Effective Objective-c 2.0 (编写高质量ios和os x的52个有效方法) 有感</h1>

<p>已经忘记在哪里看到过这么一句话“永远不用吝啬买书的钱”。这也是我在看了这本书之后的第一个感谢，收获真的太多了。虽然在我写这篇观后感的时候我才看了三分之一。一味的coding，一味的接项目，一味的实践效率真不是很高，总会觉得遇到了瓶颈，感觉自己很久没有显著提高的朋友们，其实上帝在给我们发消息呢。send_Msg(@”你该看书了！！！”)。</p>

<p>在看这本书之前，我会觉得OC其实也就那样，没什么难点嘛。其实想想自己真的很幼稚，自己接触的都只是最表面的东西，真是只要是个人都能看懂的东西。而我却自以为是的认为自己已经精通了。好了，不多说了，我们就来看看我的这些笔记吧。我相信对大部分人来说还是很受用的。</p>

<h2 id="objectivec">第一条，了解Objective-c语言的起源</h2>

<ul>
<li>
<p>OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型，收到一条消息之后究竟应执行何种代码，由运行期环境而非编译器来决定。</p>
</li>

<li>
<p>对象所占的内存总是分配在堆中的，绝不会分配在栈上，不能在栈上分配Objective-C对象。</p>

<pre><code>
NSString *someString = @&quot;The string&quot;;
NSString *anotherString = someString;
</code></pre>

<p>在堆中分配了一块内存存放@”The string”。在栈上有两个内存分别存放指针someString、anotherString，这两个指针中的内容就是堆上的@”The string”内存地址。</p>
</li>

<li>
<p>与创建结构体相比，创建对象还需要额外的开销，例如分配及释放堆内存等。如果只需要保存int、float、double、char等”非对象类型”。那么通常使用CGRect这种结构体就够了。</p>
</li>
</ul>

<h2 id="">第二条，在类的头文件中尽量少引入其他头文件</h2>

<ul>
<li>可以用“@class”(向前引用)只有在必须引入其他头文件的时候才可以引入，多余的引入其他头文件会大大地增加编译时间。</li>

<li>遇到协议之类的，必须引入其他头文件的情况时，可以把协议放在一个单独的文件中，但是对于委托协议就没有办法啦。</li>
</ul>

<h2 id="_2">第三条，多用字面量语法，少用与之等价的方法（语法糖）</h2>

<ul>
<li>
<p>字面量</p>

<pre><code>
NSNumber *intNumber = @1;
NSNumber *float = @2.5f;
NSNumber *double = @3.14159;
NSNumber *bool = @YES;
NSNumber *char = @&#39;a&#39;;
</code></pre>
</li>

<li>
<p>字面量数组</p>

<pre><code>
NSArray = @[@&quot;1&quot;,@&quot;2&quot;]; //在这里数组中的内容不能为空
</code></pre>

<p>当字面量数组或者字典中有nil时，程序会抛出异常，这有助于作者更快的发现错误，这是正常语法所不能做到的。</p>
</li>

<li>
<p>字面量语法都是不可变的，例如不可变的数组和字典，以下code可以使字面量可变</p>

<pre><code>
NSMutableArray * mutable = [@[@1,@2,@3,@4,@5]mutableCopy];
</code></pre>
</li>
</ul>

<h2 id="4define">第4条，多用类型常量，少用#define预处理指令</h2>

<ul>
<li>宏定义将会替换所有符合的字符串，且没有携带类型信息，即使有人重新定义了常量值，编译器也不会产生警告信息</li>
</ul>

<pre><code>
#define ANIMATION_DUATION    0.3

#***.m
static const NSTimeInterval kAnimationDuration = 0.3 //若局限于实现文件则前面加k，若是全局的这前面加类型前缀，这是命名规范，切记啊
</code></pre>

<pre><code>
#***.h
extern NSString *const EOCStringConstant;
#***.m
NSString *const EOCStringConstant = @&quot;Value&quot;;
</code></pre>

<p>如果试图写该const修饰的变量，编译器会报错，二static修饰符则意味着该变量仅在定义此变量的编译单元可见（实现文件）</p>

<ul>
<li>在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中。需要用类名做前缀。</li>
</ul>

<h2 id="5">第5条，用枚举表示状态、选项、状态码</h2>

<ul>
<li>指定枚举的底层数据所用类型：</li>
</ul>

<pre><code>
enum EOCConnectionState : NSInteger {/*....*/}
</code></pre>

<ul>
<li>也可以手动指定某个枚举值的值</li>

<li>Foundation框架定义了一些辅助宏，用这些宏来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型，这些宏具备向后兼容能力，如果目标平台的编译器支持新标准时，那就使用新式语法。</li>

<li>应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。</li>

<li>如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。</li>

<li>在处理枚举来信的switch语句中不要实现default分支。这样的话，加入新枚举之后编译器就会提示开发者：switch并未处理所有的枚举。</li>
</ul>

<h2 id="6">第6条，理解属性这一概念</h2>

<ul>
<li>
<p>尽量不要直接访问实例变量，而应该通过存取的方法来做。 -@dynamic,编译器不会为属性创建存取方法，也不要为其创建存取方法。在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信方法可以在运行期找到。例如CoreData中的NSManagedObject的子类。</p>
</li>

<li>
<p>属性特质：</p>

<ul>
<li>
<p>原子性：</p>

<ul>
<li>atomicity，编译器所合成的方法会通过锁定机制确保其原子性</li>

<li>nonatomic，不使用原子锁。</li>
</ul>
</li>

<li>
<p>读/写权限</p>

<ul>
<li>readwrite:可读可写，默认的。</li>

<li>readonly:只是可读的，仅有get方法，没有set方法。</li>
</ul>
</li>

<li>
<p>内存管理语义</p>

<ul>
<li>assign：只会执行针对“纯量类型”的简单赋值操作</li>

<li>strong：“拥有关系”，为这种属性设置新值时，先保留新值，再释放旧值，再将新值设置上去。</li>

<li>weak：“非拥有关系”，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，所指的对象遭到摧毁时，属性值也会清空。</li>

<li>unsafe_unretained：适用于对象类型的assign，也是“非拥有关系”，和weak不同的是，当所指的对象被销毁时，也不会自动清空，所以是不安全的。</li>

<li>copy，与strong类似，不过不保留新值，而是拷贝一份。在可变的属性中都应该拷贝一份。</li>
</ul>
</li>

<li>
<p>方法名</p>

<ul>
<li>getter = &lt;name&gt;，指定获取方法的名称。</li>

<li>setter = &lt;name&gt;，指定设置方法的名称。</li>

<li>若自定义的方法就应该具备相关属性所具备的特质。比如‘copy’，在设置方法中就应该拷贝相关对象。</li>
</ul>
</li>
</ul>
</li>
</ul>

<h2 id="_3">第七条，在对象内部经理直接访问实例变量</h2>

<ul>
<li>在写入实例变量时，通过其设置方法，而在获取实例变量时，则直接访问，可以提高读取操作速度，又可以控制属性变量的写入。</li>

<li>在初始化方法及dealloc中应该直接访问实例变量，因为子类有可能覆写设置方法。</li>

<li>‘惰性初始化’，在这种情况下，必须通过获取方法才可以访问属性。</li>
</ul>

<h2 id="_4">第八条，理解“对象等同性”这一概念</h2>

<ul>
<li>NSObject协议中有两个判断等同性的关键方法：</li>
</ul>

<pre><code>
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
</code></pre>

<h6 id="nsobjecthashhash">NSObject默认实现是当且仅当指针值完全相同时，两个对象才想等。所有我们可以在自定义类中取重载这两个方法，不过重载要注意：如果<code>isEqual:</code>方法判定两个对象想等，那么其hash方法也必须返回相同的值，但是hash返回值相同，<code>isEqual:</code>判定未必想等。</h6>

<ul>
<li>若<code>-(NSUinteger)hash</code>返回一个固定之会影响性能。假如collection是用Set实现的，set可能会根据哈希码把对象分装到不同的数组中，在向set添加新对象时要根据哈希码找到与之相关的那个数组，并依次检索各个元素。</li>

<li>不要盲目地逐个检测每条属性，二十应该依照具体需求来制定检测方案。</li>

<li>编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法。</li>
</ul>

<h2 id="_5">第九条，以类族模式隐藏实现细节</h2>

<ul>
<li><code>类族</code>是一种设计模式，可以隐藏”抽象基类”的实现细节，比如UIKit框架中的UIButton：</li>
</ul>

<pre><code>
+ (UIButton*)buttonWithType:(UIButtonType)type;
</code></pre>

<p>返回的对象取决于<code>type</code>,好像就是工厂模式。</p>

<ul>
<li>编写类族的时候要注意，
<ul>
<li>子类应该继承自类族中的抽象基类</li>

<li>子类应该定义自己的数据存储方式</li>

<li>子类应当覆写超类文档中指明需要覆盖的方法</li>
</ul>
</li>
</ul>

<h2 id="_6">第十条，在既有类中使用关联对象存放自定义数据</h2>

<ul>
<li>通过关联对象存放自定义数据，可以让你不必取基础一个父类，在子类中添加相应熟悉。</li>

<li>往一个类中添加关联数据,需要先导入<code>objc/runtime.h</code></li>
</ul>

<pre><code>
    objc_setAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;, &lt;#id value#&gt;, &lt;#objc_AssociationPolicy policy#&gt;)
</code></pre>

<ul>
<li>获取一个类中的关联数据</li>
</ul>

<pre><code>
    objc_getAssociatedObject(&lt;#id object#&gt;, &lt;#const void *key#&gt;)
</code></pre>

<ul>
<li>事例代码：</li>
</ul>

<pre><code>
static void *key = @&quot;AlertViewNewKey&quot;;
</code></pre>

<pre><code>
    UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@&quot;标题&quot;
                                                                              message:@&quot;内容&quot;
                                                                               delegate:self
                                                                 cancelButtonTitle:@&quot;cancel&quot;
                                                                 otherButtonTitles:@&quot;other&quot;, nil];
    
    void (^block)(NSInteger) = ^(NSInteger buttonIndex){
        if (buttonIndex == 0)
        {
            NSLog(@&quot;do cancel&quot;);
        }
        else
        {
            NSLog(@&quot;do Other&quot;);
        }
    };
    objc_setAssociatedObject(alertView,
                             key,
                             block,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [alertView show];
</code></pre>

<pre><code>
#pragma mark - UIAlertView Delegate
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    void(^block)(NSInteger) = objc_getAssociatedObject(alertView,key);
    block(buttonIndex);
}
</code></pre>

<ul>
<li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的”拥有关系”和“非拥有关系“</li>
</ul>
</article> <!-- end #post__content -->

<div id="post__share">
  <a id="icon-twitter" class="fontello" href="https://twitter.com/intent/tweet?url=place_your_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88-hello.html&text=OC优雅之道" target="_blank"></a>
  <a id="icon-cc" class="fontello" href="http://creativecommons.org/licenses/by-nc-sa/3.0" target="_blank"></a>
  <a id="icon-weibo" class="fontello" href="http://v.t.sina.com.cn/share/share.php?url=place_your_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88-hello.html&title=OC优雅之道" target="_blank"></a>
</div> <!-- end #post__share -->

<div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink" target="_blank">Loading Disqus comments...</a>
</div> <!-- end #disqus_thread -->

<p id="copyright">Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a>&nbsp;&nbsp;|&nbsp;&nbsp;Theme <a href="https://github.com/P233/3-Jekyll" target="_blank">3-Jekyll</a></p>
      </div> <!-- end #pjax -->

      <div id="post__toc-trigger">
        <div id="post__toc">
          <span id="post__toc-title">Table of Contents</span>
          <ul id="post__toc-ul"></ul>
        </div>
      </div>
    </div> <!-- end #post -->

    <button id="js-fullscreen"><span id="icon-arrow" class="fontello"></span></button>

    <script src="/assets/js/jquery-2.0.3.min.js"></script>
    <script src="/assets/js/jquery.pjax.js"></script>
    <script src="/assets/js/nprogress.js"></script>
    <script src="/assets/js/script.js"></script>
  </body>
</html>
