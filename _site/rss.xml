<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>place_your_blog_title_here</title>
    <link>place_your_blog_url_here</link>
    <atom:link href="place_your_blog_url_here/rss.xml" rel="self" type="application/rss+xml" />
    <description>place_your_blog_description_here</description>
    <language>place_your_blog_language_here</language>
    <pubDate>Wed, 09 Apr 2014 22:30:19 +0800</pubDate>
    <lastBuildDate>Wed, 09 Apr 2014 22:30:19 +0800</lastBuildDate>

    
    <item>
      <title>OC优雅之道</title>
      <link>place_your_blog_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/%E4%BA%BA%E7%94%9F%E6%9D%82%E8%B0%88-hello.html</link>
      <pubDate>07 Apr 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/人生杂谈-hello</guid>
      <description>&lt;h1 id=&quot;effective_objectivec_20_iosos_x52_&quot;&gt;Effective Objective-c 2.0 (编写高质量ios和os x的52个有效方法) 有感&lt;/h1&gt;

&lt;p&gt;已经忘记在哪里看到过这么一句话“永远不用吝啬买书的钱”。这也是我在看了这本书之后的第一个感谢，收获真的太多了。虽然在我写这篇观后感的时候我才看了三分之一。一味的coding，一味的接项目，一味的实践效率真不是很高，总会觉得遇到了瓶颈，感觉自己很久没有显著提高的朋友们，其实上帝在给我们发消息呢。send_Msg(@”你该看书了！！！”)。&lt;/p&gt;

&lt;p&gt;在看这本书之前，我会觉得OC其实也就那样，没什么难点嘛。其实想想自己真的很幼稚，自己接触的都只是最表面的东西，真是只要是个人都能看懂的东西。而我却自以为是的认为自己已经精通了。好了，不多说了，我们就来看看我的这些笔记吧。我相信对大部分人来说还是很受用的。&lt;/p&gt;

&lt;h2 id=&quot;objectivec&quot;&gt;第一条，了解Objective-c语言的起源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型，收到一条消息之后究竟应执行何种代码，由运行期环境而非编译器来决定。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;对象所占的内存总是分配在堆中的，绝不会分配在栈上，不能在栈上分配Objective-C对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSString *someString = @&amp;quot;The string&amp;quot;;
NSString *anotherString = someString;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在堆中分配了一块内存存放@”The string”。在栈上有两个内存分别存放指针someString、anotherString，这两个指针中的内容就是堆上的@”The string”内存地址。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;与创建结构体相比，创建对象还需要额外的开销，例如分配及释放堆内存等。如果只需要保存int、float、double、char等”非对象类型”。那么通常使用CGRect这种结构体就够了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;&quot;&gt;第二条，在类的头文件中尽量少引入其他头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以用“@class”(向前引用)只有在必须引入其他头文件的时候才可以引入，多余的引入其他头文件会大大地增加编译时间。&lt;/li&gt;

&lt;li&gt;遇到协议之类的，必须引入其他头文件的情况时，可以把协议放在一个单独的文件中，但是对于委托协议就没有办法啦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_2&quot;&gt;第三条，多用字面量语法，少用与之等价的方法（语法糖）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字面量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSNumber *intNumber = @1;
NSNumber *float = @2.5f;
NSNumber *double = @3.14159;
NSNumber *bool = @YES;
NSNumber *char = @&amp;#39;a&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;字面量数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSArray = @[@&amp;quot;1&amp;quot;,@&amp;quot;2&amp;quot;]; //在这里数组中的内容不能为空
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当字面量数组或者字典中有nil时，程序会抛出异常，这有助于作者更快的发现错误，这是正常语法所不能做到的。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;字面量语法都是不可变的，例如不可变的数组和字典，以下code可以使字面量可变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSMutableArray * mutable = [@[@1,@2,@3,@4,@5]mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4define&quot;&gt;第4条，多用类型常量，少用#define预处理指令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;宏定义将会替换所有符合的字符串，且没有携带类型信息，即使有人重新定义了常量值，编译器也不会产生警告信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
#define ANIMATION_DUATION    0.3

#***.m
static const NSTimeInterval kAnimationDuration = 0.3 //若局限于实现文件则前面加k，若是全局的这前面加类型前缀，这是命名规范，切记啊
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
#***.h
extern NSString *const EOCStringConstant;
#***.m
NSString *const EOCStringConstant = @&amp;quot;Value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果试图写该const修饰的变量，编译器会报错，二static修饰符则意味着该变量仅在定义此变量的编译单元可见（实现文件）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中。需要用类名做前缀。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5&quot;&gt;第5条，用枚举表示状态、选项、状态码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;指定枚举的底层数据所用类型：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
enum EOCConnectionState : NSInteger {/*....*/}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;也可以手动指定某个枚举值的值&lt;/li&gt;

&lt;li&gt;Foundation框架定义了一些辅助宏，用这些宏来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型，这些宏具备向后兼容能力，如果目标平台的编译器支持新标准时，那就使用新式语法。&lt;/li&gt;

&lt;li&gt;应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。&lt;/li&gt;

&lt;li&gt;如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。&lt;/li&gt;

&lt;li&gt;在处理枚举来信的switch语句中不要实现default分支。这样的话，加入新枚举之后编译器就会提示开发者：switch并未处理所有的枚举。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6&quot;&gt;第6条，理解属性这一概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽量不要直接访问实例变量，而应该通过存取的方法来做。 -@dynamic,编译器不会为属性创建存取方法，也不要为其创建存取方法。在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信方法可以在运行期找到。例如CoreData中的NSManagedObject的子类。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;属性特质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;atomicity，编译器所合成的方法会通过锁定机制确保其原子性&lt;/li&gt;

&lt;li&gt;nonatomic，不使用原子锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;读/写权限&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readwrite:可读可写，默认的。&lt;/li&gt;

&lt;li&gt;readonly:只是可读的，仅有get方法，没有set方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;内存管理语义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assign：只会执行针对“纯量类型”的简单赋值操作&lt;/li&gt;

&lt;li&gt;strong：“拥有关系”，为这种属性设置新值时，先保留新值，再释放旧值，再将新值设置上去。&lt;/li&gt;

&lt;li&gt;weak：“非拥有关系”，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，所指的对象遭到摧毁时，属性值也会清空。&lt;/li&gt;

&lt;li&gt;unsafe_unretained：适用于对象类型的assign，也是“非拥有关系”，和weak不同的是，当所指的对象被销毁时，也不会自动清空，所以是不安全的。&lt;/li&gt;

&lt;li&gt;copy，与strong类似，不过不保留新值，而是拷贝一份。在可变的属性中都应该拷贝一份。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;方法名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;getter = &amp;lt;name&amp;gt;，指定获取方法的名称。&lt;/li&gt;

&lt;li&gt;setter = &amp;lt;name&amp;gt;，指定设置方法的名称。&lt;/li&gt;

&lt;li&gt;若自定义的方法就应该具备相关属性所具备的特质。比如‘copy’，在设置方法中就应该拷贝相关对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_3&quot;&gt;第七条，在对象内部经理直接访问实例变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在写入实例变量时，通过其设置方法，而在获取实例变量时，则直接访问，可以提高读取操作速度，又可以控制属性变量的写入。&lt;/li&gt;

&lt;li&gt;在初始化方法及dealloc中应该直接访问实例变量，因为子类有可能覆写设置方法。&lt;/li&gt;

&lt;li&gt;‘惰性初始化’，在这种情况下，必须通过获取方法才可以访问属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_4&quot;&gt;第八条，理解“对象等同性”这一概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NSObject协议中有两个判断等同性的关键方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;nsobjecthashhash&quot;&gt;NSObject默认实现是当且仅当指针值完全相同时，两个对象才想等。所有我们可以在自定义类中取重载这两个方法，不过重载要注意：如果&lt;code&gt;isEqual:&lt;/code&gt;方法判定两个对象想等，那么其hash方法也必须返回相同的值，但是hash返回值相同，&lt;code&gt;isEqual:&lt;/code&gt;判定未必想等。&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;-(NSUinteger)hash&lt;/code&gt;返回一个固定之会影响性能。假如collection是用Set实现的，set可能会根据哈希码把对象分装到不同的数组中，在向set添加新对象时要根据哈希码找到与之相关的那个数组，并依次检索各个元素。&lt;/li&gt;

&lt;li&gt;不要盲目地逐个检测每条属性，二十应该依照具体需求来制定检测方案。&lt;/li&gt;

&lt;li&gt;编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_5&quot;&gt;第九条，以类族模式隐藏实现细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;类族&lt;/code&gt;是一种设计模式，可以隐藏”抽象基类”的实现细节，比如UIKit框架中的UIButton：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
+ (UIButton*)buttonWithType:(UIButtonType)type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的对象取决于&lt;code&gt;type&lt;/code&gt;,好像就是工厂模式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写类族的时候要注意，
&lt;ul&gt;
&lt;li&gt;子类应该继承自类族中的抽象基类&lt;/li&gt;

&lt;li&gt;子类应该定义自己的数据存储方式&lt;/li&gt;

&lt;li&gt;子类应当覆写超类文档中指明需要覆盖的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_6&quot;&gt;第十条，在既有类中使用关联对象存放自定义数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过关联对象存放自定义数据，可以让你不必取基础一个父类，在子类中添加相应熟悉。&lt;/li&gt;

&lt;li&gt;往一个类中添加关联数据,需要先导入&lt;code&gt;objc/runtime.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    objc_setAssociatedObject(&amp;lt;#id object#&amp;gt;, &amp;lt;#const void *key#&amp;gt;, &amp;lt;#id value#&amp;gt;, &amp;lt;#objc_AssociationPolicy policy#&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取一个类中的关联数据&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    objc_getAssociatedObject(&amp;lt;#id object#&amp;gt;, &amp;lt;#const void *key#&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;事例代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
static void *key = @&amp;quot;AlertViewNewKey&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
    UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@&amp;quot;标题&amp;quot;
                                                                              message:@&amp;quot;内容&amp;quot;
                                                                               delegate:self
                                                                 cancelButtonTitle:@&amp;quot;cancel&amp;quot;
                                                                 otherButtonTitles:@&amp;quot;other&amp;quot;, nil];
    
    void (^block)(NSInteger) = ^(NSInteger buttonIndex){
        if (buttonIndex == 0)
        {
            NSLog(@&amp;quot;do cancel&amp;quot;);
        }
        else
        {
            NSLog(@&amp;quot;do Other&amp;quot;);
        }
    };
    objc_setAssociatedObject(alertView,
                             key,
                             block,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [alertView show];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
#pragma mark - UIAlertView Delegate
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    void(^block)(NSInteger) = objc_getAssociatedObject(alertView,key);
    block(buttonIndex);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的”拥有关系”和“非拥有关系“&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>TeamTalk</title>
      <link>place_your_blog_url_here/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%B7%AF/2014/04/07/TeamTalk.html</link>
      <pubDate>07 Apr 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E8%B7%AF/2014/04/07/TeamTalk</guid>
      <description>&lt;h1 id=&quot;&quot;&gt;这是在蘑菇街的第一个项目，还在进行中，待我填完所有坑再和大家分享。敬请期待！&lt;/h1&gt;</description>
    </item>
    
    <item>
      <title>OC优雅之道</title>
      <link>place_your_blog_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/OC%281%29.html</link>
      <pubDate>07 Apr 2014</pubDate>
      <author>place_your_name_here</author>
      <guid>place_your_blog_url_here/%E4%BB%A3%E7%A0%81%E4%BC%98%E9%9B%85%E4%B9%8B%E9%81%93/2014/04/07/OC(1)</guid>
      <description>&lt;h1 id=&quot;effective_objectivec_20_iosos_x52_&quot;&gt;Effective Objective-c 2.0 (编写高质量ios和os x的52个有效方法) 有感&lt;/h1&gt;

&lt;p&gt;已经忘记在哪里看到过这么一句话“永远不用吝啬买书的钱”。这也是我在看了这本书之后的第一个感谢，收获真的太多了。虽然在我写这篇观后感的时候我才看了三分之一。一味的coding，一味的接项目，一味的实践效率真不是很高，总会觉得遇到了瓶颈，感觉自己很久没有显著提高的朋友们，其实上帝在给我们发消息呢。send_Msg(@”你该看书了！！！”)。&lt;/p&gt;

&lt;p&gt;在看这本书之前，我会觉得OC其实也就那样，没什么难点嘛。其实想想自己真的很幼稚，自己接触的都只是最表面的东西，真是只要是个人都能看懂的东西。而我却自以为是的认为自己已经精通了。好了，不多说了，我们就来看看我的这些笔记吧。我相信对大部分人来说还是很受用的。&lt;/p&gt;

&lt;h2 id=&quot;objectivec&quot;&gt;第一条，了解Objective-c语言的起源&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OC使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型，收到一条消息之后究竟应执行何种代码，由运行期环境而非编译器来决定。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;对象所占的内存总是分配在堆中的，绝不会分配在栈上，不能在栈上分配Objective-C对象。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSString *someString = @&amp;quot;The string&amp;quot;;
NSString *anotherString = someString;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在堆中分配了一块内存存放@”The string”。在栈上有两个内存分别存放指针someString、anotherString，这两个指针中的内容就是堆上的@”The string”内存地址。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;与创建结构体相比，创建对象还需要额外的开销，例如分配及释放堆内存等。如果只需要保存int、float、double、char等”非对象类型”。那么通常使用CGRect这种结构体就够了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;&quot;&gt;第二条，在类的头文件中尽量少引入其他头文件&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;可以用“@class”(向前引用)只有在必须引入其他头文件的时候才可以引入，多余的引入其他头文件会大大地增加编译时间。&lt;/li&gt;

&lt;li&gt;遇到协议之类的，必须引入其他头文件的情况时，可以把协议放在一个单独的文件中，但是对于委托协议就没有办法啦。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_2&quot;&gt;第三条，多用字面量语法，少用与之等价的方法（语法糖）&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字面量&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSNumber *intNumber = @1;
NSNumber *float = @2.5f;
NSNumber *double = @3.14159;
NSNumber *bool = @YES;
NSNumber *char = @&amp;#39;a&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;字面量数组&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSArray = @[@&amp;quot;1&amp;quot;,@&amp;quot;2&amp;quot;]; //在这里数组中的内容不能为空
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当字面量数组或者字典中有nil时，程序会抛出异常，这有助于作者更快的发现错误，这是正常语法所不能做到的。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;字面量语法都是不可变的，例如不可变的数组和字典，以下code可以使字面量可变&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
NSMutableArray * mutable = [@[@1,@2,@3,@4,@5]mutableCopy];
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4define&quot;&gt;第4条，多用类型常量，少用#define预处理指令&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;宏定义将会替换所有符合的字符串，且没有携带类型信息，即使有人重新定义了常量值，编译器也不会产生警告信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
#define ANIMATION_DUATION    0.3

#***.m
static const NSTimeInterval kAnimationDuration = 0.3 //若局限于实现文件则前面加k，若是全局的这前面加类型前缀，这是命名规范，切记啊
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
#***.h
extern NSString *const EOCStringConstant;
#***.m
NSString *const EOCStringConstant = @&amp;quot;Value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果试图写该const修饰的变量，编译器会报错，二static修饰符则意味着该变量仅在定义此变量的编译单元可见（实现文件）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;在头文件中使用extern来声明全局常量，并在相关实现文件中定义其值。这种常量要出现在全局符号中。需要用类名做前缀。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5&quot;&gt;第5条，用枚举表示状态、选项、状态码&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;指定枚举的底层数据所用类型：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
enum EOCConnectionState : NSInteger {/*....*/}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;也可以手动指定某个枚举值的值&lt;/li&gt;

&lt;li&gt;Foundation框架定义了一些辅助宏，用这些宏来定义枚举类型时，也可以指定用于保存枚举值的底层数据类型，这些宏具备向后兼容能力，如果目标平台的编译器支持新标准时，那就使用新式语法。&lt;/li&gt;

&lt;li&gt;应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。&lt;/li&gt;

&lt;li&gt;如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。&lt;/li&gt;

&lt;li&gt;在处理枚举来信的switch语句中不要实现default分支。这样的话，加入新枚举之后编译器就会提示开发者：switch并未处理所有的枚举。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6&quot;&gt;第6条，理解属性这一概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尽量不要直接访问实例变量，而应该通过存取的方法来做。 -@dynamic,编译器不会为属性创建存取方法，也不要为其创建存取方法。在编译访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信方法可以在运行期找到。例如CoreData中的NSManagedObject的子类。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;属性特质：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;atomicity，编译器所合成的方法会通过锁定机制确保其原子性&lt;/li&gt;

&lt;li&gt;nonatomic，不使用原子锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;读/写权限&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;readwrite:可读可写，默认的。&lt;/li&gt;

&lt;li&gt;readonly:只是可读的，仅有get方法，没有set方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;内存管理语义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;assign：只会执行针对“纯量类型”的简单赋值操作&lt;/li&gt;

&lt;li&gt;strong：“拥有关系”，为这种属性设置新值时，先保留新值，再释放旧值，再将新值设置上去。&lt;/li&gt;

&lt;li&gt;weak：“非拥有关系”，为这种属性设置新值时，设置方法既不保留新值，也不释放旧值，所指的对象遭到摧毁时，属性值也会清空。&lt;/li&gt;

&lt;li&gt;unsafe_unretained：适用于对象类型的assign，也是“非拥有关系”，和weak不同的是，当所指的对象被销毁时，也不会自动清空，所以是不安全的。&lt;/li&gt;

&lt;li&gt;copy，与strong类似，不过不保留新值，而是拷贝一份。在可变的属性中都应该拷贝一份。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;方法名&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;getter = &amp;lt;name&amp;gt;，指定获取方法的名称。&lt;/li&gt;

&lt;li&gt;setter = &amp;lt;name&amp;gt;，指定设置方法的名称。&lt;/li&gt;

&lt;li&gt;若自定义的方法就应该具备相关属性所具备的特质。比如‘copy’，在设置方法中就应该拷贝相关对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_3&quot;&gt;第七条，在对象内部经理直接访问实例变量&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;在写入实例变量时，通过其设置方法，而在获取实例变量时，则直接访问，可以提高读取操作速度，又可以控制属性变量的写入。&lt;/li&gt;

&lt;li&gt;在初始化方法及dealloc中应该直接访问实例变量，因为子类有可能覆写设置方法。&lt;/li&gt;

&lt;li&gt;‘惰性初始化’，在这种情况下，必须通过获取方法才可以访问属性。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_4&quot;&gt;第八条，理解“对象等同性”这一概念&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;NSObject协议中有两个判断等同性的关键方法：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
- (BOOL)isEqual:(id)object;
- (NSUInteger)hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;nsobjecthashhash&quot;&gt;NSObject默认实现是当且仅当指针值完全相同时，两个对象才想等。所有我们可以在自定义类中取重载这两个方法，不过重载要注意：如果&lt;code&gt;isEqual:&lt;/code&gt;方法判定两个对象想等，那么其hash方法也必须返回相同的值，但是hash返回值相同，&lt;code&gt;isEqual:&lt;/code&gt;判定未必想等。&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;若&lt;code&gt;-(NSUinteger)hash&lt;/code&gt;返回一个固定之会影响性能。假如collection是用Set实现的，set可能会根据哈希码把对象分装到不同的数组中，在向set添加新对象时要根据哈希码找到与之相关的那个数组，并依次检索各个元素。&lt;/li&gt;

&lt;li&gt;不要盲目地逐个检测每条属性，二十应该依照具体需求来制定检测方案。&lt;/li&gt;

&lt;li&gt;编写hash方法时，应该使用计算速度快而且哈希码碰撞率低的算法。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_5&quot;&gt;第九条，以类族模式隐藏实现细节&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;类族&lt;/code&gt;是一种设计模式，可以隐藏”抽象基类”的实现细节，比如UIKit框架中的UIButton：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
+ (UIButton*)buttonWithType:(UIButtonType)type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回的对象取决于&lt;code&gt;type&lt;/code&gt;,好像就是工厂模式。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;编写类族的时候要注意，
&lt;ul&gt;
&lt;li&gt;子类应该继承自类族中的抽象基类&lt;/li&gt;

&lt;li&gt;子类应该定义自己的数据存储方式&lt;/li&gt;

&lt;li&gt;子类应当覆写超类文档中指明需要覆盖的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;_6&quot;&gt;第十条，在既有类中使用关联对象存放自定义数据&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通过关联对象存放自定义数据，可以让你不必取基础一个父类，在子类中添加相应熟悉。&lt;/li&gt;

&lt;li&gt;往一个类中添加关联数据,需要先导入&lt;code&gt;objc/runtime.h&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    objc_setAssociatedObject(&amp;lt;#id object#&amp;gt;, &amp;lt;#const void *key#&amp;gt;, &amp;lt;#id value#&amp;gt;, &amp;lt;#objc_AssociationPolicy policy#&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;获取一个类中的关联数据&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    objc_getAssociatedObject(&amp;lt;#id object#&amp;gt;, &amp;lt;#const void *key#&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;事例代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
static void *key = @&amp;quot;AlertViewNewKey&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
    UIAlertView* alertView = [[UIAlertView alloc] initWithTitle:@&amp;quot;标题&amp;quot;
                                                                              message:@&amp;quot;内容&amp;quot;
                                                                               delegate:self
                                                                 cancelButtonTitle:@&amp;quot;cancel&amp;quot;
                                                                 otherButtonTitles:@&amp;quot;other&amp;quot;, nil];
    
    void (^block)(NSInteger) = ^(NSInteger buttonIndex){
        if (buttonIndex == 0)
        {
            NSLog(@&amp;quot;do cancel&amp;quot;);
        }
        else
        {
            NSLog(@&amp;quot;do Other&amp;quot;);
        }
    };
    objc_setAssociatedObject(alertView,
                             key,
                             block,
                             OBJC_ASSOCIATION_RETAIN_NONATOMIC);
    [alertView show];
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
#pragma mark - UIAlertView Delegate
- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
    void(^block)(NSInteger) = objc_getAssociatedObject(alertView,key);
    block(buttonIndex);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的”拥有关系”和“非拥有关系“&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>